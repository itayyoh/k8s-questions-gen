[
  {
    "question": "What is a Kubernetes Pod and what is its role in a cluster?",
    "answer": "A Pod is the smallest deployable unit in Kubernetes, running one or more containers that share storage, network, and a specification for how to run them.",
    "category": "Core Concepts",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "What is the smallest deployable unit in Kubernetes?",
    "answer": "Pod",
    "category": "Basics",
    "difficulty": "Easy",
    "options": ["Container", "Pod", "Service", "Deployment"],
    "type": "multiple-choice"
  },
  {
    "question": "How does a Kubernetes Service ensure load balancing across Pods?",
    "answer": "A Service distributes traffic across Pods using a consistent IP and DNS name, leveraging kube-proxy for load balancing via round-robin or other policies.",
    "category": "Networking",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is the purpose of a Kubernetes Namespace?",
    "answer": "A Namespace provides a way to divide cluster resources between multiple users or teams, enabling resource isolation and management within a single cluster.",
    "category": "Core Concepts",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes component is responsible for maintaining the desired state of the cluster?",
    "answer": "Controller Manager",
    "category": "Architecture",
    "difficulty": "Easy",
    "options": ["API Server", "Controller Manager", "Scheduler", "etcd"],
    "type": "multiple-choice"
  },
  {
    "question": "What is the role of kube-scheduler in a Kubernetes cluster?",
    "answer": "Kube-scheduler assigns Pods to Nodes based on resource requirements, constraints, and policies to optimize resource utilization.",
    "category": "Architecture",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What does a Kubernetes Deployment ensure for an application?",
    "answer": "A Deployment ensures that a specified number of Pods are running, handles updates, rollbacks, and scaling for stateless applications.",
    "category": "Workloads",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes object is used to manage stateful applications?",
    "answer": "StatefulSet",
    "category": "Workloads",
    "difficulty": "Medium",
    "options": ["Deployment", "StatefulSet", "DaemonSet", "Job"],
    "type": "multiple-choice"
  },
  {
    "question": "What is the function of a ConfigMap in Kubernetes?",
    "answer": "A ConfigMap stores configuration data as key-value pairs, which can be injected into Pods as environment variables, command-line arguments, or configuration files.",
    "category": "Configuration",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "How does a Kubernetes Secret differ from a ConfigMap?",
    "answer": "A Secret is used to store sensitive data like passwords or API keys, encoded in base64, while a ConfigMap stores non-sensitive configuration data.",
    "category": "Configuration",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is the primary role of etcd in a Kubernetes cluster?",
    "answer": "etcd is a distributed key-value store that holds the cluster's configuration data and state, ensuring consistency across the control plane.",
    "category": "Architecture",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes object ensures a Pod runs on every Node in the cluster?",
    "answer": "DaemonSet",
    "category": "Workloads",
    "difficulty": "Medium",
    "options": ["Deployment", "StatefulSet", "DaemonSet", "CronJob"],
    "type": "multiple-choice"
  },
  {
    "question": "What is a Kubernetes Ingress used for?",
    "answer": "An Ingress manages external HTTP/HTTPS traffic to Services, providing load balancing, SSL termination, and name-based virtual hosting.",
    "category": "Networking",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is the purpose of a Kubernetes ReplicaSet?",
    "answer": "A ReplicaSet ensures a specified number of Pod replicas are running at any given time, typically managed by a Deployment.",
    "category": "Workloads",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "Which command is used to view the logs of a Pod in Kubernetes?",
    "answer": "kubectl logs <pod-name>",
    "category": "CLI",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "What is a Kubernetes Node?",
    "answer": "A Node is a worker machine (physical or virtual) in a Kubernetes cluster that runs Pods and is managed by the control plane.",
    "category": "Core Concepts",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes component acts as the entry point for all administrative commands?",
    "answer": "API Server",
    "category": "Architecture",
    "difficulty": "Easy",
    "options": ["Controller Manager", "API Server", "Scheduler", "Kubelet"],
    "type": "multiple-choice"
  },
  {
    "question": "What does the kubectl apply command do in Kubernetes?",
    "answer": "The kubectl apply command creates or updates resources in a cluster based on a configuration file, using declarative management.",
    "category": "CLI",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is the purpose of a Kubernetes Job?",
    "answer": "A Job creates one or more Pods to run a task to completion, then terminates the Pods once the task is finished.",
    "category": "Workloads",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is a CronJob in Kubernetes used for?",
    "answer": "A CronJob schedules and runs Jobs at specified times or intervals, automating recurring tasks.",
    "category": "Workloads",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes object is used to persistently store data for Pods?",
    "answer": "PersistentVolume",
    "category": "Storage",
    "difficulty": "Medium",
    "options": ["ConfigMap", "Secret", "PersistentVolume", "Service"],
    "type": "multiple-choice"
  },
  {
    "question": "What is the difference between a PersistentVolume and a PersistentVolumeClaim?",
    "answer": "A PersistentVolume is a cluster-wide storage resource, while a PersistentVolumeClaim is a request for storage by a user or Pod that binds to a PersistentVolume.",
    "category": "Storage",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What does the kubelet do on a Kubernetes Node?",
    "answer": "The kubelet is an agent that runs on each Node, ensuring that containers in Pods are running and healthy, communicating with the API server.",
    "category": "Architecture",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is the purpose of a Kubernetes ServiceAccount?",
    "answer": "A ServiceAccount provides an identity for Pods to interact with the Kubernetes API, enabling authentication and authorization for cluster operations.",
    "category": "Security",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes resource defines policies for network access between Pods?",
    "answer": "NetworkPolicy",
    "category": "Networking",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "What is the role of kube-proxy in a Kubernetes cluster?",
    "answer": "Kube-proxy manages network rules on Nodes to enable communication between Services and Pods, facilitating load balancing and traffic routing.",
    "category": "Networking",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Which command scales a Deployment in Kubernetes?",
    "answer": "kubectl scale deployment <deployment-name> --replicas=<number>",
    "category": "CLI",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What is a Kubernetes ClusterRole?",
    "answer": "A ClusterRole defines permissions for resources across the entire cluster, used in role-based access control (RBAC) to manage access.",
    "category": "Security",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "What is the purpose of a Kubernetes Taint and Toleration?",
    "answer": "Taints mark Nodes to repel Pods unless those Pods have matching Tolerations, allowing control over where Pods are scheduled.",
    "category": "Scheduling",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "Which Kubernetes object is used to run a single task that terminates after completion?",
    "answer": "Job",
    "category": "Workloads",
    "difficulty": "Easy",
    "options": ["CronJob", "Job", "StatefulSet", "ReplicaSet"],
    "type": "multiple-choice"
  },
  {
    "question": "What is the purpose of the Kubernetes API Server?",
    "answer": "The API Server is the central management point for the cluster, handling all RESTful API requests and updating the state in etcd.",
    "category": "Architecture",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "If you have a new microservice to run in Kubernetes, what resources do you usually set up?",
    "answer": "To deploy a new microservice in Kubernetes, you typically set up a Deployment to manage Pod replicas, a Service to enable communication, and optionally an Ingress for external access. You may also configure ConfigMaps or Secrets for configuration data, and define resource limits/requests to ensure proper resource allocation.",
    "category": "Deployment",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What does a Service do in Kubernetes, and how is it different from an Ingress?",
    "answer": "A Service provides a stable IP and DNS name for accessing Pods within a cluster, enabling load balancing across them. An Ingress, however, manages external HTTP/HTTPS traffic, routing it to Services based on rules like domain or path, often requiring an Ingress Controller.",
    "category": "Networking",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "How do CRDs (Custom Resource Definitions) and Operators help you extend Kubernetes beyond its default features?",
    "answer": "CRDs allow you to define custom resources, extending Kubernetes' API to manage new object types. Operators use CRDs with custom controllers to automate complex tasks, like managing stateful applications or custom workflows, by codifying operational knowledge.",
    "category": "Extensibility",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "Your app keeps crashing after a few minutes in Kubernetes. How would you check what’s going on?",
    "answer": "To troubleshoot, check Pod logs using `kubectl logs <pod-name>`, describe the Pod with `kubectl describe pod <pod-name>` to see events, and inspect container resource usage with `kubectl top pod`. You can also use `kubectl exec` to debug inside the container or check cluster events with `kubectl get events`.",
    "category": "Troubleshooting",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Sometimes a pod or other resource is stuck 'Terminating' for a long time. Why could that happen, and what might you do?",
    "answer": "A Pod may be stuck in 'Terminating' due to finalizers, ungraceful container shutdowns, or node issues. To resolve, check for finalizers with `kubectl describe pod`, force delete with `kubectl delete pod <pod-name> --force --grace-period=0`, or troubleshoot the node for connectivity or resource issues.",
    "category": "Troubleshooting",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "You need to run commands inside a container for debugging. How do you do that in a Kubernetes environment?",
    "answer": "Use `kubectl exec -it <pod-name> -- /bin/sh` or `/bin/bash` to access a shell inside the container. If the container lacks a shell, specify a command like `kubectl exec -it <pod-name> -- <command>`. For multi-container Pods, use `-c <container-name>`.",
    "category": "Troubleshooting",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "You spot a small config mistake in a live resource. How would you fix it right away in the cluster? What risks might that cause?",
    "answer": "Edit the live resource using `kubectl edit <resource-type> <resource-name>`. This modifies the live state but risks drift from declarative configs, potential misconfigurations, or service disruptions if changes are untested. Always validate changes and update source manifests.",
    "category": "Configuration",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "How do different services within the same cluster talk to each other?",
    "answer": "Services communicate using their ClusterIP or DNS name (e.g., `<service-name>.<namespace>.svc.cluster.local`). A Service routes traffic to Pods via selectors, with kube-proxy handling load balancing. For secure communication, Network Policies or mTLS can be used.",
    "category": "Networking",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "What are sidecar containers and init containers, and why might you use them?",
    "answer": "Sidecar containers run alongside the main container in a Pod, providing auxiliary functions like logging or proxying. Init containers run sequentially before the main container starts, used for setup tasks like initializing configs or waiting for dependencies.",
    "category": "Pod Management",
    "difficulty": "Medium",
    "type": "open-ended"
  },
  {
    "question": "Is there a name length limit or other format rule for K8s resources?",
    "answer": "Kubernetes resource names are limited to 253 characters for most resources, must be lowercase alphanumeric or hyphens, and cannot start/end with a hyphen. DNS subdomain rules apply for names like Services or Ingresses.",
    "category": "Configuration",
    "difficulty": "Easy",
    "type": "open-ended"
  },
  {
    "question": "You’re running an Azure DevOps agent in Kubernetes, which uses Kaniko to build and push Docker images. It’s failing because it can’t create needed resources. How would you troubleshoot the missing permissions? How can RBAC be configured to give Kaniko the required access?",
    "answer": "To troubleshoot, check Pod logs with `kubectl logs` and describe the Pod with `kubectl describe pod` to identify permission errors. Verify RBAC with `kubectl get rolebindings,clusterrolebindings -n <namespace>`. For Kaniko, create a Role with permissions for resources like Pods and Secrets, and bind it to the ServiceAccount using a RoleBinding or ClusterRoleBinding.",
    "category": "RBAC",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "A Kubernetes Pod crashes unexpectedly, and its logs are lost because the container restarts too quickly. How would you recover logs from a previously crashed container? How can you ensure logs are always accessible?",
    "answer": "To recover logs, use `kubectl logs <pod-name> --previous` if the container is still available. To ensure logs persist, configure a logging sidecar (e.g., Fluentd or Filebeat) or send logs to a centralized system like Elasticsearch or Loki. Adjust restart policies to delay restarts if needed.",
    "category": "Logging",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "A Kubernetes Pod crashes intermittently and is marked as OOMKilled. How would you identify the cause of the memory spikes? How do you stop the Pod from running out of memory in the future?",
    "answer": "Identify memory spikes using `kubectl top pod` and monitoring tools like Prometheus. Check logs and describe the Pod for OOM events. To prevent OOMKills, set resource limits/requests in the Pod spec, optimize application memory usage, and scale horizontally if needed.",
    "category": "Troubleshooting",
    "difficulty": "Hard",
    "type": "open-ended"
  },
  {
    "question": "How do you debug issues on a Kubernetes node, such as accessing the node's file system or checking running services?",
    "answer": "SSH into the node (if permitted) to check the file system or services. Use `kubectl node-shell <node-name>` for a containerized shell if available. Check node status with `kubectl describe node <node-name>` and logs from kubelet or container runtime with `journalctl`.",
    "category": "Node Management",
    "difficulty": "Hard",
    "type": "open-ended"
  }
]